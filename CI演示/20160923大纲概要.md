#20160923大纲概要

---

###提纲

阐述不良好的PHP开发场景,主要概述我们一般常见公司的开发流程以及其中我们踩过的坑,描述一个场景新人进入公司进行开发

从`框架,架构`和`开发流程`表述

####微服务,DDD 和 单体

开发团队选择了一个使用量较广泛的 ThinkPHP 框架作为业务的开发.框架使用了 ORM 模式,是一个单体架构.

当产品人员和开发沟通需求时候,产品人员说我需要用户注册点击了一个按钮,让这个用户注册成功并发送一条欢迎短信.因为开发人员是针对数据库编程(每一个对象都是一张表),针对代码的体现是:

		//假设用户分为2张表
		M('User')->insert()
		M('UserField')->insert()
		//发送短信
		....
		
		所有的业务都会集中在一起,无论是否同一个领域(用户注册和发送短信无关)
		
我们采用DDD和事件源的模式开发
		
		//命令总线
		$commandBus = new CommandBus(new UserCommandHandlerFactory());
		$commandBus->send(new SignUpUserCommand(userName,passWord));
		//发布一个事件
		userSignUp
		
		//通知微服务(另外一个程序)
		监听到该事件后,处理发送短信
		
**理解问题**

在第一个场景中,我们所有的操作都是针对数据库操作,我们把开发还原成语言和产品沟通则是:

1. 我把数据xxx,插入用户表
2. 我把数据xxx,插入用户附属表
3. 当2长表操作成功后,我们发送一条短信给该用户
		
在第二个场景,我们再次把代码还原:

1. 我们发布一个`注册用户`命令(包含了用户名,密码)
2. 我们的命令总线处理我们的命令,处理成功后发布一个`用户已注册`事件
3. `用户领域`已经处理完成
4. 在`通知领域`我们监听到`用户已注册`事件,发送一条短信.

在第2种情况下,我们的视角永远是一个命令,不会是一个数据库.我们和产品人员的沟通可以使用通用的领域语言来沟通.

**需求更新问题**

我们需要在用户注册成功后在发一封邮件.如果在场景一中,我们需要修改原来的注册代码(尽管发送邮件和用户不同属于一个领域).但是我们在场景2中,只需要在关注的`通知领域`中修改代码即可.

####搭建环境
	
开发环境搭建费时,新人开发需要自己在windows电脑安装集成包

**问题**

* 寻找安装集成包
* 版本不统一,和测试,生产环境版本不一致
* 各种第三方扩展需要自己独立解决
* 开发人员统一使用服务器内的开发环境,每次开发完代码传到内网服务器测试

####开发部署

* 技术人员通过产品写好的需求文档,开始编写功能开发
	* 这个后期是想转变为: BDD(产品->前端服务层开发人员) 和 用户契约测试(前端服务层开发人员->后端接口)
* 写好功能代码,自测通过上传到服务器,通知测试人员测试
* 测试人员需要根据前期整理好的测试用例一个一个功能点击过去,测试通过运维人员部署到服务器
* 如果需要修改配置,则在不同的环境需要手动修改配置文件

**问题**

* 代码风格统一除了事先约定好的文档,只能靠人工审核
* 没法预防因为复制黏贴代码产生的代码耦合性问题
* 程序员和测试人员的测试只能依靠人工点击
	* 代码已经开发了一年,功能累计已经很多,需要回归测试还是靠很多人一起点击?
	* 代码需要重构,怎么保障重构后的代码符合需求

####解决方案

**环境**

通过使用`docker-compose.yml`来统一我们的开发环境,在所以电脑上启动轻量级的docker容器.

通过`ansible`推送所有部署信息到

**开发部署**

* 代码在提交时
	* 运行代码风格检测,防止代码不属于`PSR2`规范
	* 代码复制黏贴检测,防止代码耦合性太多
	* 运行单元测试
* 代码提交成功后,我们给代码打上标签`release-v大版本(架构功能大的变化).需求变更版本.bug修复版本`.只要需求变更版本不变化,则代表接口无变化.现在我们还要同步修改`deplyment/dev/docker-compose.yml`中的镜像容器仓库
* 代码push --tags, 传到github上. github触发我们镜像编译,阿里云镜像仓库会自动编译我们的代码,这里我们用了镜像分层考虑,可以加快编译速度.我们编译出2个镜像:
	* latest
	* 版本号
* 上面的数据容器镜像,也就是我们把代码统一打包到一个镜像内.我们的服务器上不会直接展示代码
* 代码编译成功后(因为需要域名,现在需要手工触发)jenkins的pipeline构建
* jenkins 从github打包我们的代码,转入到`deplyment/dev/`目录,通过`rancher-compose`远程调度我们的服务更新镜像.
* 我们的数据容器镜像会做如下操作:
	* 启动后运行我们写好的脚本`sync-config.sh`通过`conf`目录下的模板,从`etcd`拉取我们的配置数据,生成`config.php`
	* 关闭容器,因为只做数据操作使用
	





	
	 