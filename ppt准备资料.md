#PPT准备资料

---

###docker

可以理解为一个轻量级的虚拟机,发展趋势火爆.从亚马逊云,google,阿里云等云平台全面支持.容器解决方案(`google`的`kubernetes`,`官方`的`swarm`,`mesos`和`rancher`)

国内一线互联网企业也在过渡到docker容器化,`京东`,`百度`...

主要提供如下优点:

* `标准的交付件`: 取代原有的交付代码,连同环境一起交付.
* `发布速度快`: 大大简化了原先部署的时间
* `开发环境的统一`: 更方便的统一所有人的开发环境(和生产环境一致)

###微服务

我在架构方案里面已经描述了微服务的优点了.主要就是集中在:

* 单一职责
* 自治性
* 技术的异构性
* 扩展
* 弹性

####缺点

* 维护成本过于高,几何倍高于传统的单体设计.

###DDD

一种架构思路,全名为`领域驱动编程`.

传统我们基于`PHP`框架的开发模式为(`MVC`三层架构):

1. 业务需求进入
2. 我们拆分成对应的表(`orm`)
3. 基于表(`orm`对象)去编程

我们在拆分为表的时候,已经做了一层转换,即业务领域转换为一张数据表.我们在这个中间不可避免的:

1. 损失了我们的业务术语和表述,产品人员与我们沟通时我们需要把业务转换成表的数据来和产品沟通,我们的模型不具有任何业务逻辑在里面.
2. 业务逻辑会参透到`C`层中,而`M`层只是一个只有`set`和`get`方法的贫血对象.因为这个对象不包含业务逻辑.

`DDD`是一个基于4层架构设计的方法,在应用服务层之间多了一层领域服务层.不是传统的基于数据库去编程,数据库对于`DDD`只是一个基础设施服务层.

1. 我们业务可以直接还原在我们的代码中(我们是基于一个领域模型区编程),所有的模型都会有自己的方法,不是贫血的模型,这样我们就可以和`产品人员`共享一种沟通方式`领域语言`.

`DDD`只是一种理念,一种构建软件的方法论.在`PHP`中应用的不多.`java`和`.net`较为活跃.

###事件驱动

我们用`事件`解耦各个服务,使用`rabbitMq`来做队列处理之间的通信.


###CI/CD

`持续集成`和`持续交付`.

原来的`瀑布流`意味着我们对于`变更`的畏惧.现在软件开发衡量的趋势已经越来越转变为`代码从笔记本电脑到生产环境上需要多长时间`.

`传统小型互联网公司,以PHP语言为主(其他语言的开发流程没有接触过,不好过多评价)`开发流程:

* `PM`交付需求给`设计`,期间可能要和技术一起开会讨论需求.
* `设计`交付需求给`前端人员`.
* `后端人员`可以根据原型图`同步`开发我们的需求.
* `测试人员`同步编写测试用例.
* `后端人员`开发结束,交付给`测试人员`.
* `测试人员`进行回归测试,确认没有问题交付给`运维`人员部署上线.

这些流程有如下问题:

* `开发人员`,自己配置开发环境(我们可能有一些文档要求版本,但是小公司还是基于集成环境居多),难免会合生产环境的环境不一致,且开发人员部署时间耗费.
* `PM`的需求不可测试.传统我们交付的时一些`PRD`,`原型`或者各式各样的文档.但是这里面都有一个问题就是这些需求是`不可测试`的,它们是文字表述出来的意思.开发人员在开发过程中可能会产生理解的偏差.
* `测试`是纯手工形式的功能回归,会用一些工具(类似`JMeter`等做压测工具),如果初期功能少可以,但是后期随着功能迭代不断增多,测试人员做一次完整的回归测试,成本(时间)会增多.
* `PM`,`开发`和`测试`原本的沟通多是以口头交流和文档为主,但是还会经常出现.`PM`需要`A`,开发做了一个`a`,测试以为是`Aa`的场景.
* `开发`人员还原调试`bug`时间不确定性,假如一个`bug`类似注册功能,传统开发人员必须每次自己都要点击一次注册页面完善所有资料,才能提交数据然后还原`bug`,去修改.
* `运维`交付的时候一般可以使用一些自动化工具来交付,如果使用的非自动化工具以手工形式发布,这种人为不确定因素会大大增加很多.

综上所述,我们还是以`人为`因素来作开发.互联网公司是以`人`为主,但不是以一群`人`去干`重复性`劳动为主.

#####解决方案

**环境一致性**

* 我们首先可以使用`docker`解决开发环境一致性的问题.

**自动化部署开发人员环境**

* 我们可以使用类似部署服务器的模式使用一些工具(我个人使用的时`ansible`)去编写好脚本,统一部署开发人员电脑环境,在不考虑网速下载的情况几秒钟可以搭好一个环境出来.

**解决产品需求的不可测试**

产品可以参考`用户故事`方法,编写需求为用户故事用例,这些用例使用`BDD`行为驱动测试,(`php`中使用`behat`)来测试一个需求.

该需求测试主要需要描述一个用户场景,而开发人员来写代码测试该用户场景.如果全部用户故事通过,则我们认为需求通过.

在构建`流水线`中叫做`自动化用户验收测试`.

且该方法需要让`产品`,`开发人员`和`测试`一起编写.这样我们又可以做到大家对需求的理解统一性.

**自动化测试**

我们在初期就让开发人员编写测试用例,这个不用老生常谈了,所有软件开发的书籍在初期就要求编写测试代码.这个优点就不过多论述了.

**composer**

`php`的包管理工具,类似`npm`的包管理工具.统一管理我们第三方包.

**配置文件隔离解决方案**

我们开发中,开发环境,沙箱环境和生产环境的配置文件都不一致.我们可以把配置信息存储在`etcd`中(有的公司也会使用`zookeeper`)然后每次集成时候自动读取并生成配置文件.避免了我们管理不同场景的配置文件的复杂性.

**CI**

我们主要通过各种`自动化`工具,把人从传统的重复劳动中解脱出来.类似在PHP开发中,我们可以使用:

* `phpcs`检查我们的代码风格,保障所有开发人员可以开发出一致的代码风格.
* `phpunit`自动化单元测试
* `behat`自动化产品验收测试
* `mink`自动化`端到端`测试
* `phpcpd`自动化检查代码覆盖黏贴的必读,防止开发人员复制黏贴代码以至于代码耦合度过高
* ...(其他是一些代码分析工具,类似`phpmd`和`pdepend`)

**CD**

持续交付,我们通过使用`jenkins`和`git`的钩子,让我们代码在上传后自动进行测试和交付到我们需求的环境(测试或生产).

###REST接口协议

我们统一使用`REST`形式作为我们接口传输的格式,协议使用`jsonapi`(`jsonapi.org`).标准化了我们接口通信的方式,不同于以往我们每次都需要自己设计自己的接口规范,使用更标准化的`语义`模式接口.

`/Users`:

* `POST`: 代表创建
* `GET`: 代表获取列表(`/Users/1`代表获取用户id为`1`的用户)
* `PUT`: 代表`覆盖`(replace)
* `PATCH`: 代表`更新`(不过一般都会用`PUT`代表更新,没有分这么细)
* `DELETE`(`/Users/1`):代表删除用户`1`
* `OPTIONS`: 代表请求该接口有何种方法
* `HEAD`: 返回一个概要(使用的不多) 

###其他组件

* mysql 
* php 7.0
* mongodb 
* memcached 
* redis (还未确定是否使用)
* elastic search (未确定)

###监控

* rancher 自带
* k8s(如果确定使用) `heapster`

配套

* 阿里云监控

###日志

日志几种归纳分析,`ELK`但是还未最终确定.


###其他

针对前端工作流我不是太属性,类似`gulp`等.也是一套自动化方案,和后端一样.

###总结

无论是`DDD`还是`持续集成`都不是`银弹`,在享受便利和速度的情况下,维护和学习成本也会有提升.




